#include <iostream>
#include <string>
#include <vector>

// Forward declaration (needed because Note is used in Character)
struct Note;

struct Character {
    std::string name;
    int health;
    int maxHealth;
    int movementSpeed;
    std::vector<Note> inventory; // Notes the character has collected
    int x; // X position in the world
    int y; // Y position in the world

    // Constructor
    Character(std::string n, int maxHP, int speed, int startX, int startY) :
        name(n), health(maxHP), maxHealth(maxHP), movementSpeed(speed), x(startX), y(startY) {}

    void move(int dx, int dy) {
        x += dx * movementSpeed;
        y += dy * movementSpeed;
        std::cout << name << " moved to (" << x << ", " << y << ")" << std::endl;
    }

    void takeDamage(int damage) {
        health -= damage;
        if (health <= 0) {
            health = 0;
            std::cout << name << " has been defeated!" << std::endl;
        } else {
            std::cout << name << " took " << damage << " damage. Health: " << health << "/" << maxHealth << std::endl;
        }
    }

    void heal(int amount) {
        health += amount;
        if (health > maxHealth) {
            health = maxHealth;
        }
        std::cout << name << " healed for " << amount << ". Health: " << health << "/" << maxHealth << std::endl;
    }

    void collectNote(const Note& note) {
        inventory.push_back(note);
        std::cout << name << " collected a note!" << std::endl;
    }

    void showInventory(){
        std::cout << name << "'s inventory: ";
        if(inventory.empty()){
            std::cout << "empty" << std::endl;
        } else {
            for(const auto& note : inventory){
                std::cout << note.pitch << " "; // Or display other note info
            }
            std::cout << std::endl;
        }
    }
};

struct Note {
    int pitch;      // Frequency of the note
    int duration;   // How long the note plays
    int colorIndex; // Index to a color palette
};

int main() {
    Character player("Elora", 100, 2, 0, 0); // Example player

    player.move(1, 0); // Move right
    player.takeDamage(20);
    player.heal(10);
    player.move(0, -1); // Move up
    player.takeDamage(85);
    player.collectNote({60, 500, 2});
    player.showInventory();

    return 0;
}
#include <iostream>
#include <vector>
#include <random>

// Placeholder for graphics/sound libraries (SFML, SDL, etc.)
// In a real game, you would include these and use them for rendering and audio.

// Represents a musical note
struct Note {
    int pitch;      // Frequency of the note
    int duration;   // How long the note plays
    int colorIndex; // Index to a color palette
};

// Represents a region in the game world
struct Region {
    std::string name;
    std::vector<Note> ambientMusic; // Background music for the region
    // ... other region data (puzzles, environment details, etc.)
};

// Function to "play" a note (placeholder - would use a sound library in real game)
void playNote(const Note& note) {
    std::cout << "Playing note: Pitch=" << note.pitch << ", Duration=" << note.duration
              << ", Color=" << note.colorIndex << std::endl;
    // In a real game, this would play a sound and trigger visual effects.
}

// Function to "display" the world (placeholder - would use a graphics library)
void displayWorld(const Region& region) {
    std::cout << "Exploring region: " << region.name << std::endl;
    std::cout << "Ambient music: ";
    for (const auto& note : region.ambientMusic) {
        std::cout << note.pitch << " ";
    }
    std::cout << std::endl;
    // In a real game, this would render the environment.
}

int main() {
    // Example: Creating a region
    Region startingArea;
    startingArea.name = "The Whispering Woods";

    // Generate some random ambient music (placeholder)
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(40, 80); // Example pitch range

    for (int i = 0; i < 5; ++i) {
        Note n;
        n.pitch = distrib(gen);
        n.duration = 200; // Example duration
        n.colorIndex = i % 4; // Example color index
        startingArea.ambientMusic.push_back(n);
    }

    // Game loop (very simplified)
    displayWorld(startingArea);

    std::cout << "\nPlayer creates a melody note:\n";
    Note playerNote;
    playerNote.pitch = 60;
    playerNote.duration = 500;
    playerNote.colorIndex = 2;
    playNote(playerNote);

    std::cout << "\nPlayer uses a color note:\n";
    Note colorNote;
    colorNote.pitch = 0; // Color notes don't have a pitch
    colorNote.duration = 100;
    colorNote.colorIndex = 3;
    playNote(colorNote);

    std::cout << "\nGame Over (placeholder)\n";

    return 0;
}
#include <iostream>
#include <conio.h> // For _getch() (Windows-specific)
#include <limits> // Required for numeric_limits

// ... (Character and Note structs from previous example)

void handleInput(Character& player) {
    if (_kbhit()) { // Check if a key has been pressed
        char input = _getch(); // Get the pressed key

        switch (input) {
        case 'w': // Move up
            player.move(0, -1);
            break;
        case 's': // Move down
            player.move(0, 1);
            break;
        case 'a': // Move left
            player.move(-1, 0);
            break;
        case 'd': // Move right
            player.move(1, 0);
            break;
        case 'i':
            player.showInventory();
            break;
        case 'q': // Quit the game
            std::cout << "Quitting game." << std::endl;
            exit(0); // Exit the program
            break;
        default:
            std::cout << "Invalid input." << std::endl;
        }
    }
}

int main() {
    Character player("Elora", 100, 1, 0, 0);

    std::cout << "Use 'w', 'a', 's', 'd' to move. 'i' to show inventory. 'q' to quit." << std::endl;

    while (true) { // Main game loop
        handleInput(player);
        // ... other game logic (updates, rendering, etc.)
    }

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <map> // For storing skins

// ... (Character and Note structs from previous examples)

// Structure to represent a skin
struct Skin {
    std::string name;
    std::string description;
    std::string sprite; // Placeholder for actual graphics/textures
    // ... other skin attributes (e.g., special effects)
};

// Function to display a skin (placeholder)
void displaySkin(const Skin& skin) {
    std::cout << "Skin: " << skin.name << std::endl;
    std::cout << "Description: " << skin.description << std::endl;
    std::cout << "Sprite: " << skin.sprite << std::endl; // Would render the sprite in a real game
}

int main() {
    // Example skins
    std::map<std::string, Skin> availableSkins;

    availableSkins["default"] = {"Default", "The standard look.", "DefaultSprite.png"};
    availableSkins["fire"] = {"Fire Scale", "Scales imbued with fire magic.", "FireSprite.png"};
    availableSkins["ice"] = {"Ice Scale", "Scales imbued with ice magic.", "IceSprite.png"};

    // Example character
    Character player("Elora", 100, 1, 0, 0);
    std::string currentSkin = "default"; // Player's current skin

    // Display current skin
    displaySkin(availableSkins[currentSkin]);

    // Change skin (example)
    std::cout << "\nChanging skin to Fire Scale...\n";
    currentSkin = "fire";
    displaySkin(availableSkins[currentSkin]);

    // Attempt to change to a non-existent skin (error handling example)
    std::cout << "\nAttempting to change to an invalid skin...\n";
        if (availableSkins.count("invalid_skin")==0)
        {
            std::cout << "invalid skin!" << std::endl;
        }
        else
        {
            currentSkin = "invalid_skin";
            displaySkin(availableSkins[currentSkin]);
        }


    return 0;
}
#include <iostream>
#include <string>
#include <random>
#include <cmath> // For distance calculation

// ... (Character and Note structs from previous examples)

struct Enemy {
    std::string name;
    int health;
    int maxHealth;
    int attackDamage;
    int x;
    int y;
    int detectionRange; // How close the player needs to be for the enemy to notice them

    Enemy(std::string n, int maxHP, int atk, int startX, int startY, int range) :
        name(n), health(maxHP), maxHealth(maxHP), attackDamage(atk), x(startX), y(startY), detectionRange(range) {}

    void attack(Character& player) {
        player.takeDamage(attackDamage);
        std::cout << name << " attacks " << player.name << " for " << attackDamage << " damage!" << std::endl;
    }

    void moveTowards(const Character& player) {
        int dx = player.x - x;
        int dy = player.y - y;

        // Simple movement towards the player (could be improved with pathfinding)
        if (std::abs(dx) > std::abs(dy)) {
            x += (dx > 0) ? 1 : -1;
        } else {
            y += (dy > 0) ? 1 : -1;
        }
        std::cout << name << " moved to (" << x << ", " << y << ")" << std::endl;
    }

    bool isInRange(const Character& player) const {
        int dx = player.x - x;
        int dy = player.y - y;
        double distance = std::sqrt(dx * dx + dy * dy);
        return distance <= detectionRange;
    }
};

int main() {
    Character player("Elora", 100, 1, 0, 0);
    Enemy goblin("Goblin Grunt", 50, 10, 5, 5, 5); // Example enemy

    std::cout << "A " << goblin.name << " appears!" << std::endl;

    while (player.health > 0) {
        if (goblin.isInRange(player)) {
            std::cout << goblin.name << " spots " << player.name << "!" << std::endl;
            goblin.attack(player);
            player.move(1,0);
        } else {
            goblin.moveTowards(player);
        }
        if (player.health <= 0)
        {
            break;
        }
        
    }
    std::cout << "Game Over" << std::endl;
    return 0;
}
#include <iostream>
#include <string>
#include <random>
#include <cmath>
#include <vector>

// ... (Character, Note, and Enemy structs from previous examples)

void playerAttack(Character& player, Enemy& enemy) {
    // Basic attack (can be expanded with different attack types, animations, etc.)
    int damage = player.attackDamage;

    // Add note effects to the damage.
    for (const auto& note : player.inventory)
    {
        if (note.pitch > 60)
        {
            damage += 5;
        }
        else if (note.pitch < 50)
        {
            damage -= 5;
        }
    }

    enemy.takeDamage(damage);
    std::cout << player.name << " attacks " << enemy.name << " for " << damage << " damage!" << std::endl;
}

int main() {
    Character player("Elora", 100, 1, 0, 0);
    player.attackDamage = 20;
    Enemy goblin("Goblin Grunt", 50, 10, 5, 5, 5);

    std::cout << "A " << goblin.name << " appears!" << std::endl;
    player.collectNote({65, 100, 1});
    player.collectNote({45, 100, 1});
    while (player.health > 0 && goblin.health > 0) {
        playerAttack(player, goblin);
        if (goblin.health > 0)
        {
            if (goblin.isInRange(player)) {
                std::cout << goblin.name << " spots " << player.name << "!" << std::endl;
                goblin.attack(player);
                player.move(1,0);
            } else {
                goblin.moveTowards(player);
            }
        }
    }
    if (player.health <= 0)
    {
        std::cout << player.name << " has been defeated!" << std::endl;
    }
    else
    {
        std::cout << goblin.name << " has been defeated!" << std::endl;
    }
    std::cout << "Game Over" << std::endl;
    return 0;
}
#include <iostream>
#include <vector>
#include <string>

// Simplified representation of a tile
struct Tile {
    char symbol; // Character to represent the tile visually
    bool isWalkable; // Whether the player can walk on this tile
    std::string description; // Description of the tile
};

// Function to create a simple level (can be expanded for more complex levels)
std::vector<std::vector<Tile>> createLevel(int width, int height) {
    std::vector<std::vector<Tile>> level(height, std::vector<Tile>(width));

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (x == 0 || x == width - 1 || y == 0 || y == height - 1) {
                level[y][x] = {'#', false, "A sturdy wall."}; // Walls
            } else {
                level[y][x] = {'.', true, "Open ground."}; // Ground
            }
        }
    }
    return level;
}

// Function to display the level
void displayLevel(const std::vector<std::vector<Tile>>& level, int playerX, int playerY) {
    for (int y = 0; y < level.size(); ++y) {
        for (int x = 0; x < level[y].size(); ++x) {
            if (x == playerX && y == playerY) {
                std::cout << '@'; // Player symbol
            } else {
                std::cout << level[y][x].symbol;
            }
        }
        std::cout << std::endl;
    }
}

int main() {
    int levelWidth = 10;
    int levelHeight = 8;
    std::vector<std::vector<Tile>> level = createLevel(levelWidth, levelHeight);

    int playerX = 1;
    int playerY = 1;

    displayLevel(level, playerX, playerY);

    // Example interaction
    std::cout << level[playerY][playerX].description << std::endl;

    return 0;
}
#include <iostream>
#include <vector>
#include <cmath> // For sin/cos and other math functions

// ... (Other structs and functions: Character, Enemy, Note, Tile, handleInput, etc.)

// Screen dimensions (adjust these to your desired resolution)
const int SCREEN_WIDTH = 80;
const int SCREEN_HEIGHT = 24;

// Player's field of view (in degrees)
const double FOV = 60.0;

// Function to draw a single "wall" (a vertical line)
void drawWall(int x, int wallHeight) {
    if (wallHeight > SCREEN_HEIGHT) wallHeight = SCREEN_HEIGHT; // Clip walls that are too tall

    for (int y = 0; y < SCREEN_HEIGHT; ++y) {
        if (y < SCREEN_HEIGHT / 2 - wallHeight / 2) {
            std::cout << ' '; // Space above the wall
        } else if (y < SCREEN_HEIGHT / 2 + wallHeight / 2) {
            std::cout << '#'; // Wall character
        } else {
            std::cout << ' '; // Space below the wall
        }
    }
}

// Function to render the scene (basic raycasting)
void render(const Character& player, const std::vector<std::vector<Tile>>& level) {
    for (int x = 0; x < SCREEN_WIDTH; ++x) {
        // Calculate the ray's angle
        double rayAngle = (player.angle - FOV / 2.0) + (x / (double)SCREEN_WIDTH) * FOV;

        // Raycasting algorithm (very simplified)
        double rayX = player.x;
        double rayY = player.y;
        double rayDirX = std::cos(rayAngle * M_PI / 180.0); // Convert to radians
        double rayDirY = std::sin(rayAngle * M_PI / 180.0);

        int mapX = static_cast<int>(rayX);
        int mapY = static_cast<int>(rayY);

        while (mapX >= 0 && mapX < level[0].size() && mapY >= 0 && mapY < level.size() && level[mapY][mapX].symbol != '#') {
            rayX += rayDirX * 0.1; // Increment ray position
            rayY += rayDirY * 0.1;
            mapX = static_cast<int>(rayX);
            mapY = static_cast<int>(rayY);
        }

        // Calculate distance to wall
        double distance = std::sqrt(std::pow(rayX - player.x, 2) + std::pow(rayY - player.y, 2));

        // Calculate wall height based on distance (perspective)
        int wallHeight = static_cast<int>(SCREEN_HEIGHT / distance);

        drawWall(x, wallHeight);
        std::cout << std::endl;
    }
}

int main() {
    // ... (Level creation, player initialization)
    Character player("Elora", 100, 1, 1.5, 1.5);
    player.angle = 0.0; // Initial player angle

    while(true){
        render(player, level);
        //handleInput(player);
    }
    return 0;
}
#include <iostream>
#include <string>
#include <limits> // Required for numeric_limits
#include <conio.h> // For _getch() (Windows) or termios (Unix - see previous examples)
#include <unistd.h>

// ... (Character, Enemy, Note, Tile structs and other functions)

void displayStartScreen() {
    std::cout << "****************************************" << std::endl;
    std::cout << "*          Echo Bloom              *" << std::endl;
    std::cout << "****************************************" << std::endl;
    std::cout << std::endl;
    std::cout << "1. Start Game" << std::endl;
    std::cout << "2. Options (Not Implemented)" << std::endl;
    std::cout << "3. Quit" << std::endl;
    std::cout << std::endl;
    std::cout << "Enter your choice: ";
}

int getIntegerInput() {
    int choice;
    std::cin >> choice;
    // Clear error flags and ignore remaining input in case of non-numeric input
    if (std::cin.fail()) {
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return -1; // Indicate error
    }
    return choice;
}

int main() {
    int levelWidth = 10;
    int levelHeight = 8;
    std::vector<std::vector<Tile>> level = createLevel(levelWidth, levelHeight);

    int playerX = 1;
    int playerY = 1;
    Character player("Elora", 100, 1, playerX, playerY);
    player.angle = 0.0;

    while (true) {
        displayStartScreen();
        int choice = getIntegerInput();

        switch (choice) {
            case 1:
                std::cout << "Starting game..." << std::endl;
                // Main game loop (replace with your actual game logic)
                while (player.health > 0)
                {
                    render(player, level);
                    handleInput(player);
                }
                if (player.health <= 0)
                {
                    std::cout << player.name << " has been defeated!" << std::endl;
                }
                std::cout << "Game Over" << std::endl;
                return 0;
                break;
            case 2:
                std::cout << "Options are not yet implemented." << std::endl;
                break;
            case 3:
                std::cout << "Quitting game." << std::endl;
                return 0;
            default:
                std::cout << "Invalid choice. Please try again." << std::endl;
        }
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <limits>
#ifdef _WIN32
#include <conio.h>
#else
#include <termios.h>
#include <unistd.h>
#endif

// ... (Character, Enemy, Note, Tile structs and other functions)

// ANSI color codes (for Unix-like systems and some Windows terminals)
const std::map<int, std::string> colorCodes = {
    {0, "\033[0m"},    // Reset
    {1, "\033[31m"},   // Red
    {2, "\033[32m"},   // Green
    {3, "\033[33m"},   // Yellow
    {4, "\033[34m"},   // Blue
    {5, "\033[35m"},   // Magenta
    {6, "\033[36m"},   // Cyan
    {7, "\033[37m"},   // White
    {8, "\033[90m"}, //Bright Black
    {9, "\033[91m"},   // Bright Red
    {10, "\033[92m"},   // Bright Green
    {11, "\033[93m"},   // Bright Yellow
    {12, "\033[94m"},   // Bright Blue
    {13, "\033[95m"},   // Bright Magenta
    {14, "\033[96m"},   // Bright Cyan
    {15, "\033[97m"}    // Bright White
};

// Function to set text color (cross-platform)
void setTextColor(int colorIndex) {
    if (colorCodes.count(colorIndex))
    {
        std::cout << colorCodes.at(colorIndex);
    }
    else
    {
        std::cout << colorCodes.at(0);
    }
}

// Enhanced displayLevel function with color
void displayLevel(const std::vector<std::vector<Tile>>& level, int playerX, int playerY) {
    for (int y = 0; y < level.size(); ++y) {
        for (int x = 0; x < level[y].size(); ++x) {
            if (x == playerX && y == playerY) {
                setTextColor(1); // Player is red
                std::cout << '@';
                setTextColor(0); // Reset color
            } else {
                setTextColor(level[y][x].color);
                std::cout << level[y][x].symbol;
                setTextColor(0);
            }
        }
        std::cout << std::endl;
    }
}

//In Tile struct
struct Tile {
    char symbol;
    bool isWalkable;
    std::string description;
    int color; //Add color to tile
};

//Example change to create level
std::vector<std::vector<Tile>> createLevel(int width, int height) {
    std::vector<std::vector<Tile>> level(height, std::vector<Tile>(width));

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (x == 0 || x == width - 1 || y == 0 || y == height - 1) {
                level[y][x] = {'#', false, "A sturdy wall.", 4}; // Walls are blue
            } else {
                level[y][x] = {'.', true, "Open ground.", 2}; // Ground is green
            }
        }
    }
    return level;
}

int main() {
    // ... (Other game setup)
    int levelWidth = 10;
    int levelHeight = 8;
    std::vector<std::vector<Tile>> level = createLevel(levelWidth, levelHeight);

    int playerX = 1;
    int playerY = 1;
    Character player("Elora", 100, 1, playerX, playerY);
    player.angle = 0.0;

    while (true) {
        displayStartScreen();
        int choice = getIntegerInput();

        switch (choice) {
            case 1:
                std::cout << "Starting game..." << std::endl;
                // Main game loop (replace with your actual game logic)
                while (player.health > 0)
                {
                    displayLevel(level, playerX, playerY);
                    render(player, level);
                    handleInput(player);
                }
                if (player.health <= 0)
                {
                    std::cout << player.name << " has been defeated!" << std::endl;
                }
                std::cout << "Game Over" << std::endl;
                return 0;
                break;
            case 2:
                std::cout << "Options are not yet implemented." << std::endl;
                break;
            case 3:
                std::cout << "Quitting game." << std::endl;
                return 0;
            default:
                std::cout << "Invalid choice. Please try again." << std::endl;
        }
    }

    return 0;
}
#include <iostream>
#include <string>
#include <random>
#include <cmath>
#include <vector>

// ... (Character, Enemy, Note, Tile structs from previous examples)

struct Weapon {
    std::string name;
    int damage;
    std::string description;
    // ... other weapon stats (range, attack speed, etc.)
};

void playerAttack(Character& player, Enemy& enemy, const Weapon& weapon) {
    int damage = weapon.damage + player.attackDamage;
    // Add note effects to the damage.
    for (const auto& note : player.inventory)
    {
        if (note.pitch > 60)
        {
            damage += 5;
        }
        else if (note.pitch < 50)
        {
            damage -= 5;
        }
    }
    enemy.takeDamage(damage);
    std::cout << player.name << " attacks " << enemy.name << " with " << weapon.name << " for " << damage << " damage!" << std::endl;
}

int main() {
    Character player("Elora", 100, 1, 0, 0);
    player.attackDamage = 5; // base damage
    Enemy goblin("Goblin Grunt", 50, 10, 5, 5, 5);

    Weapon sword = {"Iron Sword", 15, "A basic iron sword."};
    Weapon staff = {"Wooden Staff", 10, "A simple wooden staff."};

    std::cout << "A " << goblin.name << " appears!" << std::endl;
    player.collectNote({65, 100, 1});
    player.collectNote({45, 100, 1});

    while (player.health > 0 && goblin.health > 0) {
        // Player chooses weapon (in a real game, this would be through input)
        char weaponChoice;
        std::cout << "Choose your weapon (s for sword, t for staff): ";
        std::cin >> weaponChoice;
        if (weaponChoice == 's')
        {
            playerAttack(player, goblin, sword);
        }
        else if (weaponChoice == 't')
        {
            playerAttack(player, goblin, staff);
        }
        else
        {
            std::cout << "invalid weapon choice" << std::endl;
        }
        if (goblin.health > 0)
        {
            if (goblin.isInRange(player)) {
                std::cout << goblin.name << " spots " << player.name << "!" << std::endl;
                goblin.attack(player);
                player.move(1,0);
            } else {
                goblin.moveTowards(player);
            }
        }
    }
    if (player.health <= 0)
    {
        std::cout << player.name << " has been defeated!" << std::endl;
    }
    else
    {
        std::cout << goblin.name << " has been defeated!" << std::endl;
    }
    std::cout << "Game Over" << std::endl;
    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <cmath>
#ifdef _WIN32
#include <conio.h>
#else
#include <termios.h>
#include <unistd.h>
#endif
#include <chrono>
#include <thread>

// ... (Other structs and functions: Character, Enemy, Note, Tile, handleInput, render)

// Function to simulate a delay (cross-platform)
void sleep_ms(int milliseconds) {
#ifdef _WIN32
    Sleep(milliseconds);
#else
    usleep(milliseconds * 1000);
#endif
}

void render(const Character& player, const std::vector<std::vector<Tile>>& level) {
    // ... (Raycasting code from previous example)
}

void displayLevel(const std::vector<std::vector<Tile>>& level, int playerX, int playerY, int animationFrame) {
    char playerSymbol;

    if (animationFrame == 0)
    {
        playerSymbol = '@';
    }
    else
    {
        playerSymbol = '&';
    }

    for (int y = 0; y < level.size(); ++y) {
        for (int x = 0; x < level[y].size(); ++x) {
            if (x == playerX && y == playerY) {
                setTextColor(1);
                std::cout << playerSymbol;
                setTextColor(0);
            } else {
                setTextColor(level[y][x].color);
                std::cout << level[y][x].symbol;
                setTextColor(0);
            }
        }
        std::cout << std::endl;
    }
}

int main() {
    // ... (Other game setup)
    int levelWidth = 10;
    int levelHeight = 8;
    std::vector<std::vector<Tile>> level = createLevel(levelWidth, levelHeight);

    int playerX = 1;
    int playerY = 1;
    Character player("Elora", 100, 1, playerX, playerY);
    player.angle = 0.0;
    int animationFrame = 0;

    while (true) {
        displayStartScreen();
        int choice = getIntegerInput();

        switch (choice) {
            case 1:
                std::cout << "Starting game..." << std::endl;
                // Main game loop (replace with your actual game logic)
                while (player.health > 0)
                {
                    displayLevel(level, player.x, player.y, animationFrame);
                    render(player, level);
                    handleInput(player);
                    animationFrame = (animationFrame + 1) % 2;
                    sleep_ms(200);
                }
                if (player.health <= 0)
                {
                    std::cout << player.name << " has been defeated!" << std::endl;
                }
                std::cout << "Game Over" << std::endl;
                return 0;
                break;
            case 2:
                std::cout << "Options are not yet implemented." << std::endl;
                break;
            case 3:
                std::cout << "Quitting game." << std::endl;
                return 0;
            default:
                std::cout << "Invalid choice. Please try again." << std::endl;
        }
    }

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <map>

// ... (Character and Note structs from previous examples)

// Structure to represent a skin
struct Skin {
    std::string name;
    std::string description;
    std::vector<std::string> sprites; // Now a vector of strings for animation frames
    int colorIndex; // Color index for the skin
};

// Function to display a skin (placeholder - now handles animation frames)
void displaySkin(const Skin& skin, int animationFrame) {
    std::cout << "Skin: " << skin.name << std::endl;
    std::cout << "Description: " << skin.description << std::endl;
    if (!skin.sprites.empty()) {
        std::cout << "Sprite: " << skin.sprites[animationFrame % skin.sprites.size()] << std::endl;
    } else {
        std::cout << "No sprites available for this skin." << std::endl;
    }
}

int main() {
    // Example skins with animation frames
    std::map<std::string, Skin> availableSkins;

    availableSkins["default"] = {
        "Default",
        "The standard look.",
        {"(@)", "(&)"}, // Two animation frames
        1 // Red
    };
    availableSkins["fire"] = {
        "Fire Scale",
        "Scales imbued with fire magic.",
        {"{<}", "{>}"}, // Two animation frames
        9 // Bright Red
    };
    availableSkins["ice"] = {
        "Ice Scale",
        "Scales imbued with ice magic.",
        {"[o]", "[.]"}, // Two animation frames
        12 // Bright Blue
    };
    availableSkins["no_skin"] = {
        "No Skin",
        "This skin has no sprites",
        {},
        0
    };

    // Example character
    Character player("Elora", 100, 1, 0, 0);
    std::string currentSkin = "default";
    int animationFrame = 0;

    // Display current skin (with animation)
    displaySkin(availableSkins[currentSkin], animationFrame);
    animationFrame++;
    displaySkin(availableSkins[currentSkin], animationFrame);

    // Change skin (example)
    std::cout << "\nChanging skin to Fire Scale...\n";
    currentSkin = "fire";
    displaySkin(availableSkins[currentSkin], animationFrame);
    animationFrame++;
    displaySkin(availableSkins[currentSkin], animationFrame);

    std::cout << "\nAttempting to change to an invalid skin...\n";
        if (availableSkins.count("invalid_skin")==0)
        {
            std::cout << "invalid skin!" << std::endl;
        }
        else
        {
            currentSkin = "invalid_skin";
            displaySkin(availableSkins[currentSkin], animationFrame);
        }
    return 0;
}
<!DOCTYPE html>
<html>
<head>
<title>Echo Bloom Gravity Example</title>
<style>
body { margin: 0; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;

const objects = [];

class GameObject {
  constructor(x, y, radius, color) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.color = color;
    this.velocityY = 0;
    this.gravity = 0.5; // Adjust for stronger/weaker gravity
  }

  update() {
    this.velocityY += this.gravity;
    this.y += this.velocityY;

    // Basic floor collision
    if (this.y + this.radius > canvas.height) {
      this.y = canvas.height - this.radius;
      this.velocityY = 0; // Stop falling
    }
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.closePath();
  }
}

// Create some objects
objects.push(new GameObject(100, 50, 20, 'red'));
objects.push(new GameObject(200, 100, 30, 'blue'));
objects.push(new GameObject(350, 20, 15, 'green'));


function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const obj of objects) {
    obj.update();
    obj.draw();
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Bow and Arrow</title>
<style>
body { margin: 0; overflow: hidden; } /* Prevent scrollbars */
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const bow = {
  x: 50,
  y: canvas.height / 2,
  width: 20,
  height: 80,
  angle: 0
};

const arrow = {
  x: bow.x + bow.width,
  y: bow.y,
  width: 30,
  height: 5,
  velocityX: 0,
  velocityY: 0,
  inFlight: false
};

let mouseX = 0;
let mouseY = 0;
let isDrawing = false;

canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  if (isDrawing) {
    updateBowAngle();
  }
});

canvas.addEventListener('mousedown', () => {
  isDrawing = true;
});

canvas.addEventListener('mouseup', () => {
  isDrawing = false;
  shootArrow();
});

function updateBowAngle() {
    const dx = mouseX - bow.x;
    const dy = mouseY - bow.y;
    bow.angle = Math.atan2(dy, dx);
}

function drawBow() {
  ctx.save();
  ctx.translate(bow.x, bow.y);
  ctx.rotate(bow.angle);

  ctx.fillStyle = 'brown';
  ctx.fillRect(0, -bow.height / 2, bow.width, bow.height);

  ctx.strokeStyle = 'black';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, -bow.height / 2);
  ctx.lineTo(0, bow.height / 2);
  ctx.stroke();
  ctx.closePath();


  ctx.restore();
}

function shootArrow() {
  arrow.x = bow.x + bow.width;
  arrow.y = bow.y;
  arrow.velocityX = Math.cos(bow.angle) * 10; // Adjust arrow speed
  arrow.velocityY = Math.sin(bow.angle) * 10;
  arrow.inFlight = true;
}

function updateArrow() {
  if (arrow.inFlight) {
    arrow.x += arrow.velocityX;
    arrow.y += arrow.velocityY;

    // Basic screen boundary check (arrow disappears)
    if (arrow.x > canvas.width || arrow.y < 0 || arrow.y > canvas.height) {
      arrow.inFlight = false;
    }
  }
}

function drawArrow() {
  ctx.fillStyle = 'gray';
  ctx.fillRect(arrow.x, arrow.y - arrow.height/2, arrow.width, arrow.height);
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBow();
  updateArrow();
  drawArrow();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Bow and Arrow</title>
<style>
body { margin: 0; overflow: hidden; } /* Prevent scrollbars */
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const bow = {
  x: 50,
  y: canvas.height / 2,
  width: 20,
  height: 80,
  angle: 0
};

const arrow = {
  x: bow.x + bow.width,
  y: bow.y,
  width: 30,
  height: 5,
  velocityX: 0,
  velocityY: 0,
  inFlight: false
};

let mouseX = 0;
let mouseY = 0;
let isDrawing = false;

canvas.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
  if (isDrawing) {
    updateBowAngle();
  }
});

canvas.addEventListener('mousedown', () => {
  isDrawing = true;
});

canvas.addEventListener('mouseup', () => {
  isDrawing = false;
  shootArrow();
});

function updateBowAngle() {
    const dx = mouseX - bow.x;
    const dy = mouseY - bow.y;
    bow.angle = Math.atan2(dy, dx);
}

function drawBow() {
  ctx.save();
  ctx.translate(bow.x, bow.y);
  ctx.rotate(bow.angle);

  ctx.fillStyle = 'brown';
  ctx.fillRect(0, -bow.height / 2, bow.width, bow.height);

  ctx.strokeStyle = 'black';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, -bow.height / 2);
  ctx.lineTo(0, bow.height / 2);
  ctx.stroke();
  ctx.closePath();


  ctx.restore();
}

function shootArrow() {
  arrow.x = bow.x + bow.width;
  arrow.y = bow.y;
  arrow.velocityX = Math.cos(bow.angle) * 10; // Adjust arrow speed
  arrow.velocityY = Math.sin(bow.angle) * 10;
  arrow.inFlight = true;
}

function updateArrow() {
  if (arrow.inFlight) {
    arrow.x += arrow.velocityX;
    arrow.y += arrow.velocityY;

    // Basic screen boundary check (arrow disappears)
    if (arrow.x > canvas.width || arrow.y < 0 || arrow.y > canvas.height) {
      arrow.inFlight = false;
    }
  }
}

function drawArrow() {
  ctx.fillStyle = 'gray';
  ctx.fillRect(arrow.x, arrow.y - arrow.height/2, arrow.width, arrow.height);
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBow();
  updateArrow();
  drawArrow();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Beginning Cutscene</title>
<style>
body { margin: 0; overflow: hidden; background-color: black; }
#cutscene-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: white;
  font-family: sans-serif;
  font-size: 2em;
  text-align: center;
  opacity: 0; /* Initially hidden */
  transition: opacity 1s ease-in-out; /* Smooth transitions */
}
.fade-in {
    opacity: 1;
}
.hidden{
    display: none;
}
</style>
</head>
<body>

<div id="cutscene-container">
    <div id="scene1" class="hidden">
        <p>In a world of silence...</p>
    </div>
    <div id="scene2" class="hidden">
        <p>A single sound awakens.</p>
    </div>
    <div id="scene3" class="hidden">
        <p>And color begins to bloom.</p>
    </div>
    <button id="startGame" class="hidden">Start Game</button>
</div>

<script>
const cutsceneContainer = document.getElementById('cutscene-container');
const scene1 = document.getElementById('scene1');
const scene2 = document.getElementById('scene2');
const scene3 = document.getElementById('scene3');
const startGameButton = document.getElementById('startGame');
let currentScene = 1;

function showScene(sceneNumber) {
    let sceneToShow;
    switch(sceneNumber){
        case 1:
            sceneToShow = scene1;
            break;
        case 2:
            sceneToShow = scene2;
            break;
        case 3:
            sceneToShow = scene3;
            break;
    }
    if(sceneToShow){
        sceneToShow.classList.remove("hidden");
        setTimeout(() => {
            sceneToShow.classList.add("fade-in");
        }, 50);
    }
}

function hideScene(sceneNumber){
    let sceneToHide;
    switch(sceneNumber){
        case 1:
            sceneToHide = scene1;
            break;
        case 2:
            sceneToHide = scene2;
            break;
        case 3:
            sceneToHide = scene3;
            break;
    }
    if(sceneToHide){
        sceneToHide.classList.remove("fade-in");
        setTimeout(() => {
            sceneToHide.classList.add("hidden");
        }, 1000);
    }
}

function nextScene(){
    hideScene(currentScene);
    currentScene++;
    if(currentScene <= 3){
        setTimeout(() => {
            showScene(currentScene);
        }, 1500)
    } else {
        startGameButton.classList.remove("hidden");
        startGameButton.classList.add("fade-in");
    }
}

showScene(1);
setTimeout(() => {
    nextScene();
}, 3000);
setTimeout(() => {
    nextScene();
}, 6000);
setTimeout(() => {
    nextScene();
}, 9000);

startGameButton.addEventListener('click', () => {
    // Redirect to your game or start the game logic
    window.location.href = "your_game.html"; // Replace with your game file
});
</script>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Enemy Spawning</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const enemies = [];

class Enemy {
  constructor(x, y, size, speed) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.speed = speed;
    this.dx = (Math.random() - 0.5) * this.speed; // Random horizontal direction
    this.dy = (Math.random() - 0.5) * this.speed; // Random vertical direction
  }

  update() {
    this.x += this.dx;
    this.y += this.dy;

    // Boundary collision (bounce)
    if (this.x + this.size > canvas.width || this.x - this.size < 0) {
      this.dx *= -1;
    }
    if (this.y + this.size > canvas.height || this.y - this.size < 0) {
      this.dy *= -1;
    }
  }

  draw() {
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();
  }
}

let spawnInterval;

function startSpawning(spawnRate) { // spawnRate in milliseconds
  spawnInterval = setInterval(() => {
    const size = Math.random() * 20 + 10; // Random size between 10 and 30
    const x = Math.random() * (canvas.width - size * 2) + size; // Spawn within canvas bounds
    const y = Math.random() * (canvas.height - size * 2) + size;
    const speed = Math.random() * 3 + 1; // Random speed
    enemies.push(new Enemy(x, y, size, speed));
  }, spawnRate);
}

function stopSpawning() {
  clearInterval(spawnInterval);
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < enemies.length; i++) {
    enemies[i].update();
    enemies[i].draw();
  }

  requestAnimationFrame(gameLoop);
}

startSpawning(1000); // Spawn an enemy every 1000ms (1 second)
gameLoop();

// Example of stopping spawning after 10 seconds:
setTimeout(() => {
    stopSpawning();
    console.log("Spawning stopped.")
}, 10000)

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Multiple Weapons</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
    x: 100,
    y: canvas.height / 2,
    width: 20,
    height: 40,
    currentWeapon: 0 // Index of the current weapon
};

const weapons = [
    {   // Basic projectile
        name: "Projectile",
        color: "blue",
        fireRate: 500, // Milliseconds between shots
        projectileSpeed: 10,
        projectiles: []
    },
    {   // Spread Shot
        name: "Spread Shot",
        color: "green",
        fireRate: 1000,
        projectileSpeed: 7,
        projectiles: []
    },
    {   // Beam
        name: "Beam",
        color: "yellow",
        fireRate: 200,
        beamWidth: 5,
        beamLength: 50,
        isFiring: false
    }
];

let lastFireTime = 0;

canvas.addEventListener("click", () => {
    fireWeapon();
})

function fireWeapon(){
    const now = Date.now();
    const currentWeapon = weapons[player.currentWeapon];
    if (now - lastFireTime > currentWeapon.fireRate) {
        lastFireTime = now;
        switch(currentWeapon.name){
            case "Projectile":
                currentWeapon.projectiles.push({
                    x: player.x + player.width,
                    y: player.y + player.height / 2,
                    vx: currentWeapon.projectileSpeed,
                    vy: 0
                });
                break;
            case "Spread Shot":
                for(let i = -1; i <= 1; i++){
                    currentWeapon.projectiles.push({
                        x: player.x + player.width,
                        y: player.y + player.height / 2,
                        vx: currentWeapon.projectileSpeed,
                        vy: i * 2 // Spread angle
                    });
                }
                break;
            case "Beam":
                currentWeapon.isFiring = true;
                setTimeout(() => {
                    currentWeapon.isFiring = false;
                }, 200); // Beam lasts for 200ms
                break;
        }
    }
}

document.addEventListener("keydown", (event) => {
    if (event.key == "1") {
        player.currentWeapon = 0;
    } else if (event.key == "2") {
        player.currentWeapon = 1;
    } else if (event.key == "3") {
        player.currentWeapon = 2;
    }
});

function updateProjectiles(weapon){
    for (let i = weapon.projectiles.length - 1; i >= 0; i--) {
        weapon.projectiles[i].x += weapon.projectiles[i].vx;
        weapon.projectiles[i].y += weapon.projectiles[i].vy;
        if (weapon.projectiles[i].x > canvas.width) {
            weapon.projectiles.splice(i, 1); // Remove projectile if off-screen
        }
    }
}

function drawProjectiles(weapon){
    ctx.fillStyle = weapon.color;
    for(const projectile of weapon.projectiles){
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
    }
}

function drawBeam(weapon){
    if(weapon.isFiring){
        ctx.fillStyle = weapon.color;
        ctx.fillRect(player.x + player.width, player.y + player.height/2 - weapon.beamWidth/2, weapon.beamLength, weapon.beamWidth);
    }
}

function drawPlayer() {
    ctx.fillStyle = "white";
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPlayer();

    for(const weapon of weapons){
        updateProjectiles(weapon);
        drawProjectiles(weapon);
        if(weapon.name == "Beam"){
            drawBeam(weapon);
        }
    }

    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Walking Animation</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
    x: 100,
    y: canvas.height / 2,
    width: 32, // Width of each sprite frame
    height: 48, // Height of each sprite frame
    speed: 5,
    frameIndex: 0,
    tickCount: 0,
    ticksPerFrame: 8, // Adjust for animation speed (lower = faster)
    spriteSheet: new Image()
};

player.spriteSheet.src = "player_spritesheet.png"; // Replace with your sprite sheet image

player.spriteSheet.onload = () => {
    gameLoop(); // Start the game loop after the image is loaded
};

function updatePlayer() {
    // Basic left/right movement (you can add more complex movement)
    if (keys["ArrowLeft"]) {
        player.x -= player.speed;
    }
    if (keys["ArrowRight"]) {
        player.x += player.speed;
    }

    // Animation logic
    player.tickCount++;

    if (player.tickCount > player.ticksPerFrame) {
        player.tickCount = 0;
        // Go to the next frame
        if (keys["ArrowLeft"] || keys["ArrowRight"]) { // Animate only when moving
            player.frameIndex = (player.frameIndex + 1) % 4; // Assuming 4 frames
        } else {
            player.frameIndex = 0; // Reset to idle frame
        }
    }

    // Boundary check
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
}

function drawPlayer() {
    ctx.drawImage(
        player.spriteSheet,
        player.frameIndex * player.width, // Source x
        0,                             // Source y
        player.width,                   // Source width
        player.height,                  // Source height
        player.x,                       // Destination x
        player.y,                       // Destination y
        player.width,                   // Destination width
        player.height                    // Destination height
    );
}

const keys = {};
document.addEventListener("keydown", (event) => {
    keys[event.key] = true;
});
document.addEventListener("keyup", (event) => {
    keys[event.key] = false;
});


function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updatePlayer();
    drawPlayer();
    requestAnimationFrame(gameLoop);
}

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Character Selection</title>
<style>
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-color: #f0f0f0;
}

#character-selection {
    display: flex;
    gap: 20px; /* Space between characters */
}

.character {
    cursor: pointer;
    border: 2px solid transparent; /* Initially no border */
    padding: 10px;
    transition: border-color 0.3s ease;
}

.character img {
    width: 100px;
    height: 150px;
    object-fit: contain; /* Prevents image distortion */
    display: block;
}

.character.selected {
    border-color: blue; /* Highlight selected character */
}
#start-game{
    display: none;
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 1.2em;
    cursor: pointer;
}
</style>
</head>
<body>

<div id="character-selection">
    <div class="character" id="boy">
        <img src="boy_sprite.png" alt="Boy">
        <p>Boy</p>
    </div>
    <div class="character" id="girl">
        <img src="girl_sprite.png" alt="Girl">
        <p>Girl</p>
    </div>
</div>
<button id="start-game">Start Game</button>

<script>
const characters = document.querySelectorAll('.character');
const startGameButton = document.getElementById('start-game');
let selectedCharacter = null;

characters.forEach(character => {
    character.addEventListener('click', () => {
        // Remove 'selected' class from all characters
        characters.forEach(c => c.classList.remove('selected'));

        // Add 'selected' class to the clicked character
        character.classList.add('selected');
        selectedCharacter = character.id;
        startGameButton.style.display = "block";
    });
});

startGameButton.addEventListener("click", ()=>{
    if(selectedCharacter){
        console.log("Starting Game with " + selectedCharacter);
        localStorage.setItem("selectedCharacter", selectedCharacter);
        window.location.href = "your_game.html";
    } else {
        alert("Please select a character.");
    }
});

</script>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Jump and Gravity</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
    x: 100,
    y: canvas.height - 50, // Start on the ground
    width: 20,
    height: 40,
    velocityY: 0,
    gravity: 0.5,
    isJumping: false,
    jumpForce: -10 // Negative value to move upwards
};

function updatePlayer() {
    // Gravity
    player.velocityY += player.gravity;
    player.y += player.velocityY;

    // Ground collision
    if (player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        player.velocityY = 0;
        player.isJumping = false; // Reset jump state
    }

    //Jumping
    if(keys["Space"] && !player.isJumping){
        player.velocityY = player.jumpForce;
        player.isJumping = true;
    }

    // Basic left/right movement
    if(keys["ArrowLeft"]){
        player.x -= 5;
    }
    if(keys["ArrowRight"]){
        player.x += 5;
    }

    //Boundary checks
    if(player.x < 0) player.x = 0;
    if(player.x + player.width > canvas.width) player.x = canvas.width - player.width;
}

function drawPlayer() {
    ctx.fillStyle = "white";
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

const keys = {};
document.addEventListener("keydown", (event) => {
    keys[event.code] = true; // Use event.code for better key detection
});
document.addEventListener("keyup", (event) => {
    keys[event.code] = false;
});


function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updatePlayer();
    drawPlayer();
    requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Enemies with Skins</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const enemies = [];
const enemySprites = {
    blob: new Image(),
    ghost: new Image(),
    slime: new Image()
};

enemySprites.blob.src = "blob_enemy.png"; // Replace with your image paths
enemySprites.ghost.src = "ghost_enemy.png";
enemySprites.slime.src = "slime_enemy.png";

let imagesLoaded = 0;
const totalImages = Object.keys(enemySprites).length;

for (const sprite in enemySprites) {
    enemySprites[sprite].onload = () => {
        imagesLoaded++;
        if (imagesLoaded === totalImages) {
            startGame(); // Start after all images are loaded
        }
    };
}

class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // "blob", "ghost", or "slime"
        this.size = 32; // Standard size. Adjust as needed.
        this.speed = Math.random() * 2 + 1;
        this.dx = (Math.random() - 0.5) * this.speed;
        this.dy = (Math.random() - 0.5) * this.speed;
    }

    update() {
        this.x += this.dx;
        this.y += this.dy;

        if (this.x + this.size > canvas.width || this.x < 0) this.dx *= -1;
        if (this.y + this.size > canvas.height || this.y < 0) this.dy *= -1;
    }

    draw() {
        if (enemySprites[this.type]) {
            ctx.drawImage(enemySprites[this.type], this.x, this.y, this.size, this.size);
        } else { //Fallback if image is not loaded or type is invalid
            ctx.fillStyle = "red";
            ctx.fillRect(this.x, this.y, this.size, this.size); //Draw a red square as placeholder
        }
    }
}

let spawnInterval;

function startSpawning(spawnRate) {
    spawnInterval = setInterval(() => {
        const x = Math.random() * (canvas.width - 32);
        const y = Math.random() * (canvas.height - 32);
        const enemyTypes = Object.keys(enemySprites);
        const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
        enemies.push(new Enemy(x, y, randomType));
    }, spawnRate);
}

function stopSpawning() {
    clearInterval(spawnInterval);
}

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const enemy of enemies) {
        enemy.update();
        enemy.draw();
    }

    requestAnimationFrame(gameLoop);
}

function startGame(){
    startSpawning(1000);
    gameLoop();
}

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>Screen Scrolling</title>
<style>
body { margin: 0; overflow: hidden; background-color: #333; }
canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = {
    x: 100,
    y: canvas.height - 50,
    width: 20,
    height: 40,
    speed: 5,
    velocityY: 0,
    gravity: 0.5,
    isJumping: false,
    jumpForce: -10
};

const background = {
    x: 0,
    width: 2000, // Width of your background image/area
    image: new Image()
};
background.image.src = "background.png"; // Replace with your background image

//Load the image before starting the game
background.image.onload = () => {
    gameLoop();
}

function updatePlayer() {
    // ... (Existing player update code for movement and jumping)
    if(keys["ArrowLeft"]){
        player.x -= player.speed;
        if(player.x < canvas.width/4){
            background.x += player.speed;
        }
    }
    if(keys["ArrowRight"]){
        player.x += player.speed;
        if(player.x > canvas.width*3/4){
            background.x -= player.speed;
        }
    }
    //Keep player within bounds of the middle of the screen
    if(player.x < canvas.width/4) player.x = canvas.width/4;
    if(player.x > canvas.width*3/4) player.x = canvas.width*3/4;

    if (background.x > 0) background.x = 0;
    if (background.x < -background.width + canvas.width) background.x = -background.width + canvas.width;
}

function drawBackground() {
    ctx.drawImage(background.image, background.x, 0, background.width, canvas.height);
}

function drawPlayer() {
    ctx.fillStyle = "white";
    ctx.fillRect(player.x, player.y, player.width, player.height);
}

const keys = {};
document.addEventListener("keydown", (event) => {
    keys[event.code] = true;
});
document.addEventListener("keyup", (event) => {
    keys[event.code] = false;
});

function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    updatePlayer();
    drawPlayer();
    requestAnimationFrame(gameLoop);
}

</script>
</body>
</html>
